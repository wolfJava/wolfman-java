## 初识多线程及原理分析

### 一 多线程的发展历史

#### 1 什么情况下应该使用多线程

线程出现的目的是什么？解决进程中多任务的实时性问题？其实简单来说，也就是解决“阻塞”的问题，阻塞的意思就是程序运行到某个函数或过程后等待某些事件发生而暂时停止 CPU 占用的情况，也就是说会使得 CPU 闲置。还有一 些场景就是比如对于一个函数中的运算逻辑的性能问题，我们可以通过多线程的技术，使得一个函数中的多个逻辑运算通过多线程技术达到一个并行执行，从而提升性能。

所以，多线程最终解决的就是“等待”的问题，所以简单总结的使用场景 

Ø 通过并行计算提高程序执行性能

Ø 需要等待网络、I/O响应导致耗费大量的执行时间，可以采用异步线程的方式来减少阻塞

#### 2 tomcat7 以前的 io 模型

多线程的应用场景

- 客户端阻塞：如果客户端只有一个线程，这个线程发起读取文件的操作必须等待 IO 流返回，线程(客户端)才能做其他的事

- 线程级别阻塞 BIO 客户端一个线程情况下，一个线程导致整个客户端阻塞。 那么我们可以使用多线程，一部分线程在等待 IO 操作返回，其他线程可以继续做其他的事。此时从客户端角度来说，客户端没有闲着。

### 二 如何应用多线程

在 Java 中，有多种方式来实现多线程。继承 Thread 类、实现 Runnable 接 口、使用 ExecutorService、Callable、Future 实现带返回结果的多线程。 

#### 1 继承 Thread 类创建线程 

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它会启动一个新线程，并执行 run()方法。这种方式实现多线程很简单，通过自己的类直接 extend Thread，并复写 run()方法，就可以启动新线程并执行自己定义的 run()方法。

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread.run()");
    }
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread1.start();
        myThread2.start();
    }
}
~~~

#### 2 实现 Runnable 接口创建线程

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时， 可以实现一个 Runnable 接口 

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("MyRunnable.run()");
    }
}
~~~

#### 3 实现 Callable 接口通过 FutureTask 包装器来创建Thread 线程

有的时候，我们可能需要让一步执行的线程在执行完成以后，提供一个返回值给到当前的主线程，主线程需要依赖这个值进行后续的逻辑处理，那么这个时候，就需要用到带返回值的线程了。Java 中提供了这样的实现方式。

~~~java
public class MyCallable implements Callable<String> {

    @Override
    public String call() throws Exception {
        int a=1;
        int b=2;
        System.out.println(a+b);
        return "执行结果:"+(a+b);
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService= Executors.newFixedThreadPool(1);
        MyCallable myCallable = new MyCallable();
        Future<String> future = executorService.submit(myCallable);
        System.out.println(future.get());
        executorService.shutdown();
    }
}
~~~

#### 4 如何把多线程用得更加优雅

合理的利用异步操作，可以大大提升程序的处理性能，下面这个案例，如果看 过 zookeeper 源码的同学应该都见过，通过阻塞队列以及多线程的方式，实现对请求的异步化处理，提升处理性能。

### 三 Java 并发编程的基础

线程作为操作系统调度的最小单元，并且能够让多线程同时执行，极大的提高了程序的性能，在多核环境下的优势更加明显。但是在使用多线程的过程中，如果对它的特性和原理不够理解的话，很容易造成各种问题。

#### 1 线程的状态

Java 线程既然能够创建，那么也势必会被销毁，所以线程是存在生命周期的，那么我们接下来从线程的生命周期开始去了解线程。

线程一共有 6 种状态(NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED)

- NEW：初始状态，线程被构建，但是还没有调用 start 方法
- RUNNABLED：运行状态，JAVA 线程把操作系统中的就绪和运行两种状态统一称为“运行中”
- BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况
  - 等待阻塞：运行的线程执行wait方法，jvm会把当前线程放入到等待队列
  - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中
  - 其他阻塞：运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复

- TIME_WAITING：超时等待状态，超时以后自动返回
- TERMINATED：终止状态，表示当前线程执行完毕

![](https://github.com/wolfJava/wolfman-java/blob/master/java-multi-thread/img/multi-thread-1.jpg?raw=true)

#### 2 通过代码演示线程的状态

~~~java
public class ThreadStatus {

    public static void main(String[] args) {
        //TIME_WAITING
        new Thread(()->{
            while (true){
                try {
                    TimeUnit.SECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"timewaiting").start();
        //WAITING，线程在 ThreadStatus 类锁上通过 wait 进行等待
        new Thread(()->{
            while(true){
                synchronized (ThreadStatus.class){
                    try {
                        ThreadStatus.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } }
            }
        },"Waiting").start();
        //线程在 ThreadStatus 加锁后，不会释放锁
        new Thread(new BlockedDemo(),"BlockDemo-01").start();
        new Thread(new BlockedDemo(),"BlockDemo-02").start();

    }

    static class BlockedDemo extends Thread{
        public void run(){
            synchronized (BlockedDemo.class){
                while(true){
                    try {
                        TimeUnit.SECONDS.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
~~~

#### 3 通过相应命令显示线程状态

- 打开终端或者命令提示符，键入“jps”，(JDK1.5 提供的一个显示当前所有 java 进程 pid 的命令)，可以获得相应进程的 pid 
- 根据上一步骤获得的 pid，继续输入 jstack pid(jstack 是 java 虚拟机自带的 一种堆栈跟踪工具。jstack 用于打印出给定的 java 进程 ID 或 core file 或远程 调试服务的 Java 堆栈信息) 

#### 4 线程的停止

线程的启动过程大家都非常熟悉，但是如何终止一个线程，我相信绝大部分人在面试的时候被问到这个问题时，也会不知所措，不知道怎么回答。

记住，线程的终止，并不是简单的调用 stop 命令去。虽然 api 仍然可以调用， 但是和其他的线程控制方法如 suspend、resume 一样都是过期了的不建议使用，就拿 stop 来说，stop 方法在结束一个线程时并不会保证线程的资源正常释放，因此会导致程序可能出现一些不确定的状态。 要优雅的去中断一个线程，在线程中提供了一个 interrupt 方法 

##### 4.1 interrupt 方法

当其他线程通过调用当前线程的 interrupt 方法，表示向当前线程打个招呼， 告诉他可以中断线程的执行了，至于什么时候中断，取决于当前线程自己。 

线程通过检查资深是否被中断来进行相应，可以通过 isInterrupted()来判断是 否被中断。 

~~~java
//通过下面这个例子，来实现了线程终止的逻辑
public class InterruptDemo {
    private static int i;
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            while(!Thread.currentThread().isInterrupted()){
                i++;
            }
            System.out.println("Num:"+i);
        },"interruptDemo");
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();
    }
}
~~~

这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。

##### 4.2 Thread.interrupted

上面的案例中，通过 interrupt，设置了一个标识告诉线程可以终止了，线程中还提供了静态方法Thread.interrupted()对设置中断标识的线程复位。比如在上面的案例中，外面的线程调用 thread.interrupt 来设置中断标识，而在线程里面，又通过 Thread.interrupted 把线程的标识又进行了复位。

~~~java
public class Interrupt2Demo {

    private static int i;

    public static void main(String[] args) throws
            InterruptedException{
        Thread thread=new Thread(()->{
            while(true){
                boolean ii=Thread.currentThread().isInterrupted();
                if(ii){
                    System.out.println("before:"+ii);
                    Thread.interrupted();//对线程进行复位，中断标识为false
                    System.out.println("after:"+Thread.currentThread()
                            .isInterrupted());
                }
                i++;
                System.out.println("Num:"+i);
            }
        });
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();//设置中断标识,中断标识为 true
    }

}
~~~

##### 4.3 其他的线程复位

除了通过 Thread.interrupted 方法对线程中断标识进行复位以外，还有一种被动复位的场景，就是对抛出 InterruptedException 异常的方法，在InterruptedException 抛出之前，JVM 会先把线程的中断标识位清除，然后才会抛出 InterruptedException，这个时候如果调用 isInterrupted 方法，将会返回 false

~~~java
public class Interrupt3Demo {
    public static void main(String[] args) throws
            InterruptedException{
        Thread thread=new Thread(()->{
            while(true){
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    //抛出该异常，会将复位标识设置为 false
                    e.printStackTrace();
                }
            }
        });
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();//设置复位标识为 true
        TimeUnit.SECONDS.sleep(1);
        System.out.println(thread.isInterrupted());//false
    }
}
~~~

其实就是通过 unpark 去唤醒当前线程，并且设置一个标识位为 true。 并没有所谓的中断线程的操作，所以实际上，线程复位可以用来实现多个线程之间的通信。 

##### 4.4 线程的停止方法之 2

除了通过 interrupt 标识为去中断线程以外，我们还可以通过下面这种方式，定义一个 volatile 修饰的成员变量，来控制线程的终止。这实际上是应用了 volatile 能够实现多线程之间共享变量的可见性这一特点来实现的。

### 四 线程的安全性问题

其实线程安全问题可以总结为: 可见性、原子性、有序性这几个问题，我们搞懂了这几个问题并且知道怎么解决，那么多线程安全性问题也就不是问题了。

#### 1 CPU 高速缓存

线程是 CPU 调度的最小单元，线程涉及的目的最终仍然是更充分的利用计算机处理的效能，但是绝大部分的运算任务不能只依靠处理器“计算”就能完成，处理器还需要与内存交互，比如读取运算数据、存储运算结果，这个 I/O 操作是很难消除的。而由于计算机的存储设备与处理器的运算速度差距非常大，所以现代计算机系统都会增加一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲:将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中。

![](https://github.com/wolfJava/wolfman-java/blob/master/java-multi-thread/img/multi-thread-2.jpg?raw=true)

高速缓存从下到上越接近 CPU 速度越快，同时容量也越小。现在大部分的处理器都有二级或者三级缓存，从下到上依次为 L3 cache, L2 cache, L1 cache. 缓存又可以分为指令缓存和数据缓存，指令缓存用来缓存程序的代码，数据缓存用来缓存程序的数据。

L1 Cache，一级缓存，本地 core 的缓存，分成 32K 的数据缓存 L1d 和 32k 指 令缓存 L1i，访问 L1 需要 3cycles，耗时大约 1ns; 

L2 Cache，二级缓存，本地 core 的缓存，被设计为 L1 缓存与共享的 L3 缓存 之间的缓冲，大小为 256K，访问 L2 需要 12cycles，耗时大约 3ns; 

L3 Cache，三级缓存，在同插槽的所有 core 共享 L3 缓存，分为多个 2M 的 段，访问 L3 需要 38cycles，耗时大约 12ns; 























