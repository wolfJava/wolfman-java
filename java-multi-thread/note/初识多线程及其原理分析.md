## 初识多线程及原理分析

### 一 多线程的发展历史

#### 1 什么情况下应该使用多线程

线程出现的目的是什么？解决进程中多任务的实时性问题？其实简单来说，也就是解决“阻塞”的问题，阻塞的意思就是程序运行到某个函数或过程后等待某些事件发生而暂时停止 CPU 占用的情况，也就是说会使得 CPU 闲置。还有一 些场景就是比如对于一个函数中的运算逻辑的性能问题，我们可以通过多线程的技术，使得一个函数中的多个逻辑运算通过多线程技术达到一个并行执行，从而提升性能。

所以，多线程最终解决的就是“等待”的问题，所以简单总结的使用场景 

Ø 通过并行计算提高程序执行性能

Ø 需要等待网络、I/O响应导致耗费大量的执行时间，可以采用异步线程的方式来减少阻塞

#### 2 tomcat7 以前的 io 模型

多线程的应用场景

- 客户端阻塞：如果客户端只有一个线程，这个线程发起读取文件的操作必须等待 IO 流返回，线程(客户端)才能做其他的事

- 线程级别阻塞 BIO 客户端一个线程情况下，一个线程导致整个客户端阻塞。 那么我们可以使用多线程，一部分线程在等待 IO 操作返回，其他线程可以继续做其他的事。此时从客户端角度来说，客户端没有闲着。

### 二 如何应用多线程

在 Java 中，有多种方式来实现多线程。继承 Thread 类、实现 Runnable 接 口、使用 ExecutorService、Callable、Future 实现带返回结果的多线程。 

#### 1 继承 Thread 类创建线程 

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它会启动一个新线程，并执行 run()方法。这种方式实现多线程很简单，通过自己的类直接 extend Thread，并复写 run()方法，就可以启动新线程并执行自己定义的 run()方法。

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread.run()");
    }
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread1.start();
        myThread2.start();
    }
}
~~~

#### 2 实现 Runnable 接口创建线程

如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时， 可以实现一个 Runnable 接口 

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("MyRunnable.run()");
    }
}
~~~

#### 3 实现 Callable 接口通过 FutureTask 包装器来创建Thread 线程

有的时候，我们可能需要让一步执行的线程在执行完成以后，提供一个返回值给到当前的主线程，主线程需要依赖这个值进行后续的逻辑处理，那么这个时候，就需要用到带返回值的线程了。Java 中提供了这样的实现方式。

~~~java
public class MyCallable implements Callable<String> {

    @Override
    public String call() throws Exception {
        int a=1;
        int b=2;
        System.out.println(a+b);
        return "执行结果:"+(a+b);
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService= Executors.newFixedThreadPool(1);
        MyCallable myCallable = new MyCallable();
        Future<String> future = executorService.submit(myCallable);
        System.out.println(future.get());
        executorService.shutdown();
    }
}
~~~

#### 4 如何把多线程用得更加优雅

合理的利用异步操作，可以大大提升程序的处理性能，下面这个案例，如果看 过 zookeeper 源码的同学应该都见过，通过阻塞队列以及多线程的方式，实现对请求的异步化处理，提升处理性能。

### 三 Java 并发编程的基础

线程作为操作系统调度的最小单元，并且能够让多线程同时执行，极大的提高了程序的性能，在多核环境下的优势更加明显。但是在使用多线程的过程中，如果对它的特性和原理不够理解的话，很容易造成各种问题。

#### 1 线程的状态

Java 线程既然能够创建，那么也势必会被销毁，所以线程是存在生命周期的，那么我们接下来从线程的生命周期开始去了解线程。

线程一共有 6 种状态(NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED)

- NEW：初始状态，线程被构建，但是还没有调用 start 方法
- RUNNABLED：运行状态，JAVA 线程把操作系统中的就绪和运行两种状态统一称为“运行中”
- BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况
  - 等待阻塞：运行的线程执行wait方法，jvm会把当前线程放入到等待队列
  - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中
  - 其他阻塞：运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复

- TIME_WAITING：超时等待状态，超时以后自动返回
- TERMINATED：终止状态，表示当前线程执行完毕









BLOCKED:阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃 

了 CPU 使用权，阻塞也分为几种情况
 





































